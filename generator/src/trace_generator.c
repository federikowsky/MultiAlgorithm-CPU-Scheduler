#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <dirent.h>
#include <time.h>
#include <sys/stat.h>

#include "../include/trace_generator.h"

char usage_buffer[1024] = "Usage: %s <num_process> <num_burst_per_process> <histogram_folder> <dest_folder> \n\
\n\
<num_process>: Number of processes to create and simulate. \n\
<burst_per_process>: Number of burst per process. \n\
<histogram_folder>: The path to the folder containing the histogram data. \n\
<dest_folder>: The path to the folder where the traces will be saved. NOTE! all the files in the folder will be deleted. if the folder does not exist it will be created. \n\
\n";

/**
 * @brief Normalize the probabilities of the histogram
 *
 * @param probabilities array of probabilities generated by the histogram
 * @param size size of the array
 */
void normalize(float *probabilities, int size)
{
	float sum = 0.0;
	for (int i = 0; i < size; i++)
	{
		sum += probabilities[i];
	}
	for (int i = 0; i < size; i++)
	{
		probabilities[i] /= sum;
	}
}

/**
 * @brief uniform sampling algorithm which generates num_desired_samples samples and stores them in sampled_indices
 *        depending on the probabilities of the histogram
 *
 * @param sampled_indices array to store the sampled indices
 * @param probabilities array of probabilities generated by the histogram
 * @param num_probabilities number of probabilities in the array
 * @param num_desired_samples number of samples to generate
 */
void uniformSample(int *sampled_indices, float *probabilities, int num_probabilities, int num_desired_samples)
{
	// Normalizzazione delle probabilità
	normalize(probabilities, num_probabilities);

	// Passo per le y(i)
	float step = 1.0 / num_desired_samples;

	// Seleziona un valore y(0) casuale tra 0 e 1/num_desired_samples
	float y0 = (float)rand() / RAND_MAX * step;
	float yi = y0;

	// Variabili cumulative
	float cumulative = 0.0;
	int sample_index = 0;

	// Esegui il campionamento
	for (int prob_index = 0; prob_index < num_probabilities; prob_index++)
	{
		cumulative += probabilities[prob_index];

		// Riempie con l'indice della probabilità corrente
		while (cumulative > yi && sample_index < num_desired_samples)
		{
			sampled_indices[sample_index] = prob_index;
			sample_index++;
			yi += step;
		}
	}
}

/**
 * @brief get a burst (CPU or I/O) duration based on uniform sampling
 *
 * @param hist array of burst histograms
 * @param size size of the array
 * @param num_samples number of samples to generate
 * @return int
 */
int getBurstDuration(BurstDist *hist, int size, int num_samples)
{
	int sampled_index[num_samples];
	float probabilities[size];

	// Copy probabilities into the probabilities array
	for (int i = 0; i < size; i++)
	{
		probabilities[i] = hist[i].probability;
	}

	// Apply the uniform sampling algorithm and save the indices in sampled_index
	uniformSample(sampled_index, probabilities, size, num_samples);

	// Return the burst duration corresponding to the first sample
	return hist[sampled_index[0]].burst_time;
}

/**
 * @brief Create a process and put it in the list of processes to be created
 *
 * @param os The fake OS instance
 * @param proc_num The process number to create
 */
void createEventProc(BurstProfile *bf, int proc_id, int bursts_per_process, const char *dest_folder)
{
    // create file for the process events
    char filename[256], burst_type[8];
    FILE *file;
    int burst_time, priority, arrival;

    
    sprintf(filename, "%s/process_%d.txt", dest_folder, proc_id);
    if((file = fopen(filename, "w")) == NULL)
        assert(file && "Could not open file");


    // write the process id to the file and the number of bursts
    priority = rand() % MAX_PRIORITY;
    arrival = rand() % 100;
    if (fprintf(file, "# Proc: %-3d Burst_num: %-3d From: %s\nPriority: %d\nArrival: %d\n", proc_id, bursts_per_process, bf->source_type, priority, arrival) < 0)
        assert(0 && "fprintf failed");


	// Create a number of bursts for the process based on the number of bursts per process
	// and the histograms for CPU and I/O burst
	// The process will have alternating CPU and I/O bursts
	for (int i = 0; i < bursts_per_process; i++)
	{
		// Generate a random number to decide if the next burst is a CPU or I/O burst
		double random_val = (double)rand() / RAND_MAX;

		if (random_val < 0.5)
		{
			// Generate a random burst duration based on the CPU burst histogram
            burst_time = getBurstDuration(bf->cpu_hist, bf->cpu_size, 1);
            strcpy(burst_type, "CPU");
		} else {
			// Generate a random burst duration based on the I/O burst histogram
            burst_time = getBurstDuration(bf->io_hist, bf->io_size, 1);
            strcpy(burst_type, "IO");
		}
        // Write the event to the file
        if ((fprintf(file, "%-3s %4d\n", burst_type, burst_time)) < 0)
            assert(0 && "fprintf failed");
	}
    
    fclose(file);
    return;
}

/**
 * @brief Initialize the TraceGen structure
 *
 * @param tg The TraceGen structure to initialize
 * @param num_processes Number of processes to create
 * @param burst_per_process Number of burst per process
 * @param histogram_folder The path to the folder containing the histogram data
 */
void TraceGen_init(TraceGen *tg, int num_processes, int burst_per_process, const char *histogram_folder)
{
    tg->num_processes = num_processes;
    tg->histogram_folder = histogram_folder;
    tg->burst_per_process = burst_per_process;
    List_init(&tg->burst_profiles);

    return;
}

/**
 * @brief Load a histogram from a file
 *
 * @param filename The path to the file containing the histogram data
 * @return BurstProfile*
 */
BurstProfile *BurstProfile_loadHistogram(const char *filename)
{
    char line[256];
    int is_cpu = 0, is_io = 0;
    int cpu_count = 0, io_count = 0;
	BurstDist cpu_hist_temp[100], io_hist_temp[100];
    BurstProfile *bf;
    FILE *file;

    if((file = fopen(filename, "r")) == NULL)
        assert(file && "file not found");

    while (fgets(line, sizeof(line), file))
	{
		if (line[0] == '#' || line[0] == '\n')
            continue;

        if (strncmp(line, "CPU_BURST", 9) == 0)
		{
            is_cpu = 1;
            is_io = 0;
            continue;
        }
        if (strncmp(line, "IO_BURST", 8) == 0)
		{
            is_io = 1;
            is_cpu = 0;
            continue;
        }

		// Find the position of comment if present
        char *comment_pos = strchr(line, '#');
        if (comment_pos) {
            *comment_pos = '\0'; // Truncate the line at the comment
        }

        // Parse burst time and probability
        int burst_time;
        double probability;
        if (sscanf(line, "%d %lf", &burst_time, &probability) == 2 || sscanf(line, "%d,%lf", &burst_time, &probability) == 2)
		{
            if (is_cpu)
			{
                cpu_hist_temp[cpu_count].burst_time = burst_time;
                cpu_hist_temp[cpu_count].probability = probability;
                cpu_count++;
            } 
			else if (is_io)
			{
                io_hist_temp[io_count].burst_time = burst_time;
                io_hist_temp[io_count].probability = probability;
                io_count++;
            }
        }
    }

    fclose(file);

    // Allocate memory for the BurstProfile
    if ((bf = (BurstProfile *)malloc(sizeof(BurstProfile))) == NULL)
        assert(0 && "malloc failed");
    if ((bf->cpu_hist = (BurstDist *)malloc(cpu_count * sizeof(BurstDist))) == NULL)
        assert(0 && "malloc failed");
    if ((bf->io_hist = (BurstDist *)malloc(io_count * sizeof(BurstDist))) == NULL)
        assert(0 && "malloc failed");

    // Copy data from temp arrays
    memcpy(bf->cpu_hist, cpu_hist_temp, cpu_count * sizeof(BurstDist));
    memcpy(bf->io_hist, io_hist_temp, io_count * sizeof(BurstDist));
	bf->cpu_size = cpu_count;
	bf->io_size = io_count;

    // Save the source type of the histogram without extension
    char *source_type = strrchr(filename, '/');
    source_type = (source_type == NULL) ? (char *)filename : source_type + 1; // ignore the last '/'

    char *ext = strrchr(source_type, '.');
    if (ext != NULL) {
        *ext = '\0';  // Truncate the extension
    }

    bf->source_type = strdup(source_type);

    return bf;
}



int main(int argc, char **argv)
{
    TraceGen        tg;
    DIR             *dir;
    struct dirent   *ent;


    if (argc != 5)
    {
        printf(usage_buffer, argv[0]);
        return 1;
    }

    srand(time(NULL));

    int num_processes = atoi(argv[1]);
    int burst_per_process = atoi(argv[2]);
    const char *histogram_folder = argv[3];
    const char *dest_folder = argv[4];

    if (num_processes < 1 || burst_per_process < 1)
    {
        printf(usage_buffer, argv[0]);
        return 1;
    }

    // Create the destination folder if it does not exist
    struct stat st = {0};
    if (stat(dest_folder, &st) == -1)
    {
        mkdir(dest_folder, 0700);
    } 
    // Delete all the files in the folder
    else
    {
        char cmd[256];
        sprintf(cmd, "rm -f %s/*", dest_folder);
        system(cmd);
    }

    TraceGen_init(&tg, num_processes, burst_per_process, histogram_folder);

    // Open the histogram folder and load the histograms into the burst_profiles list
    if ((dir = opendir(histogram_folder)) == NULL)
        assert(0 && "Could not open histogram folder");

    while ((ent = readdir(dir)) != NULL)
    {
        if (ent->d_type == DT_REG)
        {
            char filename[256];
            sprintf(filename, "%s/%s", histogram_folder, ent->d_name);
            BurstProfile *bf = BurstProfile_loadHistogram(filename);
            List_pushBack(&tg.burst_profiles, &bf->list);
        }
    }
    closedir(dir);

    // Create the processes events based on the loaded histograms 
    // and save them in a file
    for (int i = 0; i < num_processes; i++)
    {
        int profile_index = rand() % tg.burst_profiles.size;
        BurstProfile *bf = (BurstProfile *)List_getAt(&tg.burst_profiles, profile_index);
        createEventProc(bf, i, burst_per_process, dest_folder);
    }

    // Free the memory allocated for the histograms
    ListItem *aux;
    while ((aux = List_popFront(&tg.burst_profiles)) != NULL)
    {
        BurstProfile *bf = (BurstProfile *)aux;
        free(bf->cpu_hist);
        free(bf->io_hist);
        free(bf->source_type);
        free(bf);
    }

    return 0;
}