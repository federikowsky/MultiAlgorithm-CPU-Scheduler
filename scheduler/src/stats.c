#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "../include/fake_os.h"

/**
 * @brief 
 * 
 * @param cpu_hist The array of CPU burst histograms.
 * @param size The size of the array.
 * @return The weighted mean of CPU burst times.
 */
float calculateWeightedMean(const BurstHistogram *cpu_hist, int size)
{
	static float weighted_sum = 0.0;
	float total_probability = 0.0;

	if (weighted_sum)
		return weighted_sum;

	for (int i = 0; i < size; i++) {
		weighted_sum += cpu_hist[i].burst_time * cpu_hist[i].probability;
		total_probability += cpu_hist[i].probability;
	}

	float weighted_mean = weighted_sum / total_probability;
	return weighted_mean;
}


/**
 * @brief Normalize the probabilities of the histogram
 *
 * @param probabilities array of probabilities generated by the histogram
 * @param size size of the array
 */
void normalize(float *probabilities, int size)
{
	float sum = 0.0;
	for (int i = 0; i < size; i++)
	{
		sum += probabilities[i];
	}
	for (int i = 0; i < size; i++)
	{
		probabilities[i] /= sum;
	}
}

/**
 * @brief uniform sampling algorithm which generates num_desired_samples samples and stores them in sampled_indices
 *        depending on the probabilities of the histogram
 *
 * @param sampled_indices array to store the sampled indices
 * @param probabilities array of probabilities generated by the histogram
 * @param num_probabilities number of probabilities in the array
 * @param num_desired_samples number of samples to generate
 */
void uniformSample(int *sampled_indices, float *probabilities, int num_probabilities, int num_desired_samples)
{
	// Normalizzazione delle probabilità
	normalize(probabilities, num_probabilities);

	// Passo per le y(i)
	float step = 1.0 / num_desired_samples;

	// Seleziona un valore y(0) casuale tra 0 e 1/num_desired_samples
	float y0 = (float)rand() / RAND_MAX * step;
	float yi = y0;

	// Variabili cumulative
	float cumulative = 0.0;
	int sample_index = 0;

	// Esegui il campionamento
	for (int prob_index = 0; prob_index < num_probabilities; prob_index++)
	{
		cumulative += probabilities[prob_index];

		// Riempie con l'indice della probabilità corrente
		while (cumulative > yi && sample_index < num_desired_samples)
		{
			sampled_indices[sample_index] = prob_index;
			sample_index++;
			yi += step;
		}
	}
}

/**
 * @brief generate a burst (CPU or I/O) duration based on uniform sampling
 *
 * @param hist array of burst histograms
 * @param size size of the array
 * @param num_samples number of samples to generate
 * @return int
 */

int generateBurstDuration(BurstHistogram *hist, int size, int num_samples)
{
	int sampled_index[num_samples];
	float probabilities[size];

	// Copy probabilities into the probabilities array
	for (int i = 0; i < size; i++)
	{
		probabilities[i] = hist[i].probability;
	}

	// Apply the uniform sampling algorithm and save the indices in sampled_index
	uniformSample(sampled_index, probabilities, size, num_samples);

	// Return the burst duration corresponding to the first sample
	return hist[sampled_index[0]].burst_time;
}
